<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QuickChat | Private Messaging with In-Built Games & Reactions</title>
<meta name="description" content="QuickChat is an enhanced, real-time private messaging application featuring user-to-user chats, community rooms, message reactions, and built-in games like Tic Tac Toe.">
<meta name="keywords" content="quickchat, chat app, firebase chat, web chat, private messaging, in-chat games, tic tac toe">
<style>
:root{--bg:#0b0f14;--elev:#111723;--border:#1b2435;--text:#e6eefc;--muted:#98a7c0;--brand:#4f8cff}
body.theme-high { --bg:#05070b; --elev:#0a1120; --border:#172135; --text:#eaf2ff; --muted:#9fb1cc; --brand:#4f8cff }
body.theme-dim { --bg:#0b0f14; --elev:#111723; --border:#1b2435; --text:#e6eefc; --muted:#98a7c0; --brand:#4f8cff }

html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)} 
.app{display:flex;flex-direction:column;height:100%} 
header{display:flex;align-items:center;gap:.6rem;padding:.7rem;background:linear-gradient(180deg,var(--elev),#0e1420);border-bottom:1px solid var(--border)} 
.title{font-weight:700;font-size:1.4rem} 
.spacer{flex-grow:1} 
.nav-btn{background:var(--elev);color:var(--text);border:1px solid var(--border);border-radius:.3rem;padding:.5rem;cursor:pointer;font-weight:600;transition:background-color .2s} 
.nav-btn:hover{background:#1b2435} 
.nav-btn:active{background:#233045} 
#loginScreen,#loadingScreen{position:fixed;top:0;left:0;width:100%;height:100%;background:var(--bg);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100} 
#loadingScreen p{font-size:1.2rem;font-weight:500} 
#chatScreen{display:none;flex-grow:1;overflow:hidden} 
.chat-container{display:flex;flex-grow:1;overflow:hidden} 
#userList,#roomList{width:250px;overflow-y:auto;border-right:1px solid var(--border);background:var(--elev)} 
.user-item,.room-item{padding:.8rem;cursor:pointer;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:.7rem;transition:background-color .2s} 
.user-item:hover,.room-item:hover{background:#151d2c} 
.avatar{width:40px;height:40px;border-radius:50%;object-fit:cover;border:2px solid var(--brand)} 
.active-dot{width:10px;height:10px;background:lime;border-radius:50%;position:absolute;transform:translate(25px,15px);border:2px solid var(--elev)} 
.user-name{font-weight:600} 
.room-name{font-weight:600} 
#mainChat{flex-grow:1;display:flex;flex-direction:column;overflow:hidden} 
.message-list{flex-grow:1;overflow-y:auto;padding:.5rem 1rem} 
.message{display:flex;align-items:flex-start;gap:.5rem;margin-bottom:.5rem;background:var(--bg);padding:.3rem;border-radius:.5rem} 
.message-content{flex-grow:1} 
.message-header{display:flex;align-items:center;gap:.5rem;font-size:.9rem} 
.message-sender{font-weight:700;color:var(--brand)} 
.message-time{font-size:.8rem;color:var(--muted)} 
.message-text{margin-top:.3rem;white-space:pre-wrap;word-break:break-word} 
.reaction-container{font-size:.8rem;color:var(--muted);margin-top:.2rem} 
.reaction-btn{cursor:pointer;margin-right:.5rem} 
.chat-input{display:flex;padding:.5rem;border-top:1px solid var(--border);gap:.5rem;background:var(--elev)} 
#msgInput{flex-grow:1;padding:.7rem;border:1px solid var(--border);border-radius:.3rem;background:var(--bg);color:var(--text);font-size:1rem} 
#msgInput:focus{outline:none;border-color:var(--brand)} 
#sendBtn{padding:.7rem 1.2rem;background:var(--brand);color:#fff;border:none;border-radius:.3rem;cursor:pointer;font-weight:600;transition:opacity .2s} 
#sendBtn:disabled{opacity:.5;cursor:not-allowed} 
.emoji-picker{position:absolute;bottom:70px;right:20px;background:var(--elev);border:1px solid var(--border);border-radius:.5rem;padding:.5rem;display:grid;grid-template-columns:repeat(8,1fr);gap:.3rem;z-index:50} 
.emoji-btn{cursor:pointer;font-size:1.2rem;background:transparent;border:none;padding:.2rem} 
.active-room-header{padding:.7rem;border-bottom:1px solid var(--border);background:var(--elev);font-weight:600} 
#profileAdminPanel{position:absolute;top:50px;right:10px;background:var(--elev);border:1px solid var(--border);border-radius:.5rem;padding:.8rem;z-index:60;display:none;min-width:150px} 
#profileAdminPanel button{width:100%;padding:.5rem;margin-top:.5rem;background:var(--brand);color:#fff;border:none;border-radius:.3rem;cursor:pointer} 
.game-container{padding:1rem;background:var(--bg);border-radius:.5rem;margin-top:.5rem} 
.game-board{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;width:150px;margin:0 auto} 
.game-cell{width:50px;height:50px;background:var(--elev);display:flex;align-items:center;justify-content:center;font-size:2rem;cursor:pointer;border-radius:.3rem;border:1px solid var(--border)} 
.game-cell:hover{background:#151d2c} 
.game-status{text-align:center;margin-top:.5rem;font-weight:600;color:var(--brand)}
#typingIndicator{font-size:.8rem;color:var(--brand);padding:0 10px;display:none}
</style>
</head>
<body>

<div id="loadingScreen">
  <p>Loading QuickChat...</p>
</div>

<div id="loginScreen" style="display:none;">
  <div style="background:var(--elev);padding:2rem;border-radius:.5rem;border:1px solid var(--border);text-align:center">
    <h2>Welcome to QuickChat</h2>
    <p>Sign in to start messaging and playing games!</p>
    <button id="googleSignInBtn" class="nav-btn" style="background:#4285f4;color:#fff;margin-top:1rem">
      <img src="https://upload.wikimedia.org/wikipedia/commons/4/4a/Logo_Google_g_standard.png" alt="Google logo" style="width:20px;vertical-align:middle;margin-right:.5rem">
      Sign in with Google
    </button>
  </div>
</div>

<div id="chatScreen">
  <div class="app">
    <header>
      <div class="title">QuickChat</div>
      <div class="spacer"></div>
      <div id="userStatus" class="nav-btn" style="background:lime;color:#000;font-weight:bold;display:none;">Online</div>
      <button id="darkModeToggle" class="nav-btn"></button>
      <img id="navAvatar" class="avatar" style="cursor:pointer;" src="" alt="User Avatar">
      <div id="profileAdminPanel">
        <p id="profileName" style="font-weight:bold;margin-bottom:.5rem;"></p>
        <button id="logoutBtn">Sign Out</button>
      </div>
    </header>
    
    <div class="chat-container">
      <div id="roomList">
        <div style="padding:.7rem;font-weight:bold;border-bottom:1px solid var(--border);background:#0e1420;">Community Rooms</div>
      </div>
      
      <div id="userList">
        <div style="padding:.7rem;font-weight:bold;border-bottom:1px solid var(--border);background:#0e1420;">Direct Messages</div>
      </div>
      
      <div id="mainChat">
        <div id="activeRoomHeader" class="active-room-header">
          Welcome to QuickChat! Select a Room or User to begin.
        </div>
        
        <div id="typingIndicator"></div>

        <div class="message-list">
          </div>
        
        <div class="chat-input">
          <input type="text" id="msgInput" placeholder="Send a message...">
          <button id="emojiBtn" class="nav-btn" style="padding:0 .8rem;">ðŸ˜€</button>
          <button id="sendBtn" disabled>Send</button>
        </div>
        
        <div id="emojiPicker" class="emoji-picker" style="display:none;">
          </div>
        
        <div id="gameArea" style="padding:0 1rem;">
          </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
// NOTE: You must replace these placeholders with your actual Firebase configuration
// If you used AI to create the site, this part should already be connected to your database.
const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
    projectId: "YOUR_PROJECT_ID",
    storageBucket: "YOUR_PROJECT_ID.appspot.com",
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
    appId: "YOUR_APP_ID"
};

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getFirestore, collection, doc, query, orderBy, limit, addDoc, serverTimestamp, onSnapshot, updateDoc, arrayUnion, arrayRemove, setDoc, deleteDoc, where, getDoc, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const provider = new GoogleAuthProvider();

// ========================== GLOBAL STATE ==========================
let currentUser = null;
let activeChatType = 'room'; // 'room' or 'user'
let activeChatId = 'general';
let unsubscribeMessages = null;

// ========================== DOM ELEMENTS ==========================
const $ = (id) => document.getElementById(id);
const $msgInput = $('msgInput');
const $sendBtn = $('sendBtn');
const $messageList = document.querySelector('.message-list');
const $userList = $('userList');
const $roomList = $('roomList');
const $loginScreen = $('loginScreen');
const $loadingScreen = $('loadingScreen');
const $chatScreen = $('chatScreen');
const $activeRoomHeader = $('activeRoomHeader');
const $navAvatar = $('navAvatar');
const $profileName = $('profileName');

// ========================== AUTHENTICATION ==========================
$('googleSignInBtn').onclick = async () => {
    try {
        await signInWithPopup(auth, provider);
    } catch (error) {
        console.error("Sign-in error:", error);
    }
};

onAuthStateChanged(auth, async (user) => {
    $loadingScreen.style.display = 'flex';
    if (user) {
        currentUser = user;
        
        // Update user status and profile info
        await setUserStatus(user.uid, true, user.displayName, user.photoURL);
        
        $navAvatar.src = user.photoURL || 'default_avatar.png';
        $profileName.textContent = user.displayName;
        
        $loginScreen.style.display = 'none';
        $chatScreen.style.display = 'flex';
        
        // Initial setup
        setupRoomsListener();
        setupUsersListener();
        
        // Default to 'general' room
        await switchChat('room', 'general');

    } else {
        currentUser = null;
        
        // Clear status if signed out
        if(currentUser) await setUserStatus(currentUser.uid, false);
        
        $chatScreen.style.display = 'none';
        $loginScreen.style.display = 'flex';
        
        // Clear chat area
        $messageList.innerHTML = '';
        $userList.innerHTML = '<div style="padding:.7rem;font-weight:bold;border-bottom:1px solid var(--border);background:#0e1420;">Direct Messages</div>';
        $roomList.innerHTML = '<div style="padding:.7rem;font-weight:bold;border-bottom:1px solid var(--border);background:#0e1420;">Community Rooms</div>';
        $activeRoomHeader.textContent = 'Welcome to QuickChat! Select a Room or User to begin.';
    }
    $loadingScreen.style.display = 'none';
});

// ========================== USER STATUS & LISTING ==========================
async function setUserStatus(uid, isOnline, displayName, photoURL) {
    const userRef = doc(db, 'users', uid);
    if (isOnline) {
        // Set last seen now, but keep displayName and photoURL
        await setDoc(userRef, { 
            uid,
            displayName: displayName, 
            photoURL: photoURL, 
            isOnline: true,
            lastSeen: serverTimestamp() 
        }, { merge: true });
    } else {
        // Set offline and update last seen
        await updateDoc(userRef, { isOnline: false, lastSeen: serverTimestamp() });
    }
}

function setupUsersListener() {
    const q = query(collection(db, 'users'), orderBy('displayName'));
    onSnapshot(q, (snapshot) => {
        // Keep header, clear the rest
        $userList.innerHTML = '<div style="padding:.7rem;font-weight:bold;border-bottom:1px solid var(--border);background:#0e1420;">Direct Messages</div>'; 
        snapshot.forEach(doc => {
            const user = doc.data();
            if (user.uid === currentUser.uid) return; // Skip current user
            
            const userItem = document.createElement('div');
            userItem.className = 'user-item';
            userItem.setAttribute('data-uid', user.uid);
            userItem.innerHTML = `
                <div style="position:relative;">
                    <img class="avatar" src="${user.photoURL || 'default_avatar.png'}" alt="${user.displayName}">
                    ${user.isOnline ? '<div class="active-dot"></div>' : ''}
                </div>
                <div class="user-name">${user.displayName}</div>
            `;
            userItem.onclick = () => switchChat('user', user.uid, user.displayName);
            $userList.appendChild(userItem);
        });
    });
}

// ========================== ROOMS & LISTING ==========================
function setupRoomsListener() {
    const q = query(collection(db, 'rooms'), orderBy('name'));
    onSnapshot(q, (snapshot) => {
        $roomList.innerHTML = '<div style="padding:.7rem;font-weight:bold;border-bottom:1px solid var(--border);background:#0e1420;">Community Rooms</div>';
        snapshot.forEach(doc => {
            const room = doc.data();
            const roomItem = document.createElement('div');
            roomItem.className = 'room-item';
            roomItem.setAttribute('data-rid', doc.id);
            roomItem.innerHTML = `
                <div class="room-name">#${room.name}</div>
            `;
            roomItem.onclick = () => switchChat('room', doc.id, room.name);
            $roomList.appendChild(roomItem);
        });
    });
}

// ========================== CHAT SWITCHING LOGIC ==========================
async function switchChat(type, id, name) {
    if (unsubscribeMessages) {
        unsubscribeMessages(); // Stop listening to old chat
    }
    
    activeChatType = type;
    activeChatId = id;
    
    // Update header
    if (type === 'room') {
        $activeRoomHeader.textContent = `#${name || id}`;
    } else {
        $activeRoomHeader.textContent = `Chatting with: ${name || id}`;
    }
    
    $messageList.innerHTML = ''; // Clear old messages
    $sendBtn.disabled = false; // Enable input

    // Set up message listener for the new chat
    setupMessageListener(type, id);
    
    // Check for active game
    await checkActiveGame(type, id);
}

// ========================== MESSAGING ==========================
function getChatRef(type, id) {
    if (type === 'room') {
        return collection(db, 'rooms', id, 'messages');
    } else {
        // Direct Message: Use a canonical ID based on UIDs
        const chatID = [currentUser.uid, id].sort().join('_');
        return collection(db, 'dms', chatID, 'messages');
    }
}

function setupMessageListener(type, id) {
    const messagesRef = getChatRef(type, id);
    const q = query(messagesRef, orderBy('createdAt', 'desc'), limit(100)); // Limit to last 100 messages

    unsubscribeMessages = onSnapshot(q, (snapshot) => {
        $messageList.innerHTML = ''; // Clear and re-render messages
        
        snapshot.docChanges().reverse().forEach((change) => {
            const msg = change.doc.data();
            if (change.type === 'added' || change.type === 'modified') {
                displayMessage(msg, change.doc.id);
            }
        });
        
        // Scroll to bottom after rendering
        $messageList.scrollTop = $messageList.scrollHeight;
    });
}

function displayMessage(msg, docId) {
    const existingMsg = $(`msg-${docId}`);
    if (existingMsg) {
        existingMsg.remove();
    }
    
    const messageEl = document.createElement('div');
    messageEl.className = 'message';
    messageEl.id = `msg-${docId}`;
    
    const time = msg.createdAt ? new Date(msg.createdAt.seconds * 1000).toLocaleTimeString() : '...';
    
    // Get sender's display name, or use 'Unknown' if not available
    const senderName = msg.senderName || 'Unknown';
    const isCurrentUser = msg.senderId === currentUser.uid;
    
    messageEl.innerHTML = `
        <img class="avatar" src="${msg.senderPhotoURL || 'default_avatar.png'}" alt="${senderName}" style="width:30px;height:30px;">
        <div class="message-content">
            <div class="message-header">
                <span class="message-sender" style="color:${isCurrentUser ? 'var(--brand)' : 'var(--text)'};">${isCurrentUser ? 'You' : senderName}</span>
                <span class="message-time">${time}</span>
            </div>
            <div class="message-text">${msg.text}</div>
            <div class="reaction-container">
                ${renderReactions(docId, msg.reactions)}
            </div>
        </div>
    `;
    
    $messageList.appendChild(messageEl);
}

// ========================== REACTION LOGIC ==========================
const availableReactions = ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ”¥', 'ðŸŽ‰'];

function renderReactions(msgId, reactions = {}) {
    let html = '';
    
    availableReactions.forEach(emoji => {
        const users = reactions[emoji] || [];
        if (users.length > 0) {
            const hasReacted = users.includes(currentUser.uid);
            const count = users.length;
            const tooltip = users.map(uid => uid === currentUser.uid ? 'You' : 'User').join(', ');
            
            html += `
                <span class="reaction-btn" 
                      data-msg-id="${msgId}" 
                      data-emoji="${emoji}" 
                      title="${tooltip}"
                      style="color:${hasReacted ? 'var(--brand)' : 'var(--muted)'};font-weight:${hasReacted ? 'bold' : 'normal'};"
                      onclick="window.toggleReaction('${msgId}', '${emoji}')">
                    ${emoji} ${count}
                </span>
            `;
        }
    });
    
    // Add buttons for adding a new reaction
    availableReactions.forEach(emoji => {
        const users = reactions[emoji] || [];
        if (users.length === 0 && !Object.keys(reactions).some(e => reactions[e].includes(currentUser.uid))) {
             html += `
                <span class="reaction-btn" 
                      data-msg-id="${msgId}" 
                      data-emoji="${emoji}" 
                      title="Add ${emoji} reaction"
                      style="color:var(--muted); opacity: 0.5;"
                      onclick="window.toggleReaction('${msgId}', '${emoji}')">
                    ${emoji}
                </span>
            `;
        }
    });
    
    return html;
}

window.toggleReaction = async (msgId, emoji) => {
    const docRef = doc(getChatRef(activeChatType, activeChatId), msgId);
    const uid = currentUser.uid;

    try {
        await runTransaction(db, async (transaction) => {
            const docSnapshot = await transaction.get(docRef);
            if (!docSnapshot.exists()) {
                throw "Document does not exist!";
            }

            const currentReactions = docSnapshot.data().reactions || {};
            const newReactions = { ...currentReactions };
            let alreadyReacted = false;

            // Check if user has reacted with this emoji
            const users = newReactions[emoji] || [];
            if (users.includes(uid)) {
                // User is removing their reaction
                newReactions[emoji] = users.filter(id => id !== uid);
                if (newReactions[emoji].length === 0) {
                    delete newReactions[emoji];
                }
            } else {
                // User is adding a reaction
                alreadyReacted = Object.keys(newReactions).some(e => newReactions[e].includes(uid));
                
                if (alreadyReacted) {
                    // Remove existing reaction before adding the new one (one reaction per user)
                    Object.keys(newReactions).forEach(e => {
                        newReactions[e] = newReactions[e].filter(id => id !== uid);
                        if (newReactions[e].length === 0) {
                            delete newReactions[e];
                        }
                    });
                }
                
                // Add the new reaction
                newReactions[emoji] = [...(newReactions[emoji] || []), uid];
            }
            
            transaction.update(docRef, { reactions: newReactions });
        });
    } catch (e) {
        console.error("Reaction transaction failed: ", e);
    }
};

// ========================== SEND MESSAGE ==========================
$msgInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !$sendBtn.disabled) {
        sendMessage();
    }
});

$sendBtn.onclick = sendMessage;

async function sendMessage() {
    const text = $msgInput.value.trim();
    if (!text || !currentUser) return;
    
    $sendBtn.disabled = true;
    
    const newMessage = {
        text: text,
        createdAt: serverTimestamp(),
        senderId: currentUser.uid,
        senderName: currentUser.displayName,
        senderPhotoURL: currentUser.photoURL,
        reactions: {}
    };
    
    try {
        const messagesRef = getChatRef(activeChatType, activeChatId);
        await addDoc(messagesRef, newMessage);
        $msgInput.value = '';
    } catch (error) {
        console.error("Error sending message:", error);
    }
    
    $sendBtn.disabled = false;
    // Scroll to bottom after sending
    $messageList.scrollTop = $messageList.scrollHeight;
}

// ========================== EMOJI PICKER ==========================
const $emojiPicker = $('emojiPicker');
const $emojiBtn = $('emojiBtn');

availableReactions.forEach(emoji => {
    const btn = document.createElement('button');
    btn.className = 'emoji-btn';
    btn.textContent = emoji;
    btn.onclick = () => {
        $msgInput.value += emoji;
        $msgInput.focus();
        $emojiPicker.style.display = 'none';
    };
    $emojiPicker.appendChild(btn);
});

$emojiBtn.onclick = () => {
    $emojiPicker.style.display = $emojiPicker.style.display === 'none' ? 'grid' : 'none';
};

// ========================== GAMES (Tic-Tac-Toe) ==========================
const $gameArea = $('gameArea');
let gameRef = null;
let gameUnsubscribe = null;
let boardData = Array(9).fill(null);
let gameStatus = '';

const getGameRef = (type, id) => {
    if (type === 'room') {
        return doc(db, 'rooms', id, 'game', 'tictactoe');
    } else {
        const chatID = [currentUser.uid, id].sort().join('_');
        return doc(db, 'dms', chatID, 'game', 'tictactoe');
    }
};

function renderGameBoard() {
    $gameArea.innerHTML = `
        <div class="game-container">
            <h4 style="text-align:center; margin:0 0 10px 0;">Tic Tac Toe</h4>
            <div class="game-board">
                ${boardData.map((cell, index) => `
                    <div class="game-cell" data-index="${index}" onclick="window.makeMove(${index})">
                        ${cell || ''}
                    </div>
                `).join('')}
            </div>
            <div id="gameStatus" class="game-status">${gameStatus}</div>
            <div style="text-align:center;margin-top:10px;">
                <button id="startGameBtn" class="nav-btn" style="background:green;">Start New Game</button>
                <button id="forfeitGameBtn" class="nav-btn" style="background:red;margin-left:10px;">Forfeit</button>
            </div>
        </div>
    `;
    $('startGameBtn').onclick = startGame;
    $('forfeitGameBtn').onclick = forfeitGame;
}

const checkWinner = (board) => {
    const lines = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
        [0, 4, 8], [2, 4, 6]            // Diagonals
    ];

    for (let i = 0; i < lines.length; i++) {
        const [a, b, c] = lines[i];
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            return board[a];
        }
    }
    if (board.every(cell => cell !== null)) {
        return 'Draw';
    }
    return null;
};

async function checkActiveGame(type, id) {
    if (gameUnsubscribe) gameUnsubscribe();
    $gameArea.innerHTML = '';
    
    gameRef = getGameRef(type, id);
    
    gameUnsubscribe = onSnapshot(gameRef, (docSnapshot) => {
        if (docSnapshot.exists()) {
            const game = docSnapshot.data();
            boardData = game.board;
            gameStatus = formatGameStatus(game);
            renderGameBoard();
        } else {
            $gameArea.innerHTML = `<div class="game-container"><button id="initGameBtn" class="nav-btn" style="background:green;">Start Tic Tac Toe</button></div>`;
            $('initGameBtn').onclick = startGame;
        }
    });
}

const formatGameStatus = (game) => {
    const winner = checkWinner(game.board);
    if (winner === 'Draw') return 'Game Over: Draw!';
    if (winner) return `Game Over: ${winner === 'X' ? game.playerXName : game.playerOName} (${winner}) wins!`;
    if (!game.playerOId) return 'Waiting for an opponent...';
    
    const currentPlayer = game.turn === 'X' ? game.playerXName : game.playerOName;
    return `${currentPlayer}'s turn (${game.turn})`;
};

async function startGame() {
    const newGame = {
        board: Array(9).fill(null),
        turn: 'X',
        playerXId: currentUser.uid,
        playerXName: currentUser.displayName,
        playerOId: activeChatType === 'user' ? activeChatId : null,
        playerOName: activeChatType === 'user' ? $activeRoomHeader.textContent.replace('Chatting with: ', '') : null,
        status: 'active',
        createdAt: serverTimestamp()
    };
    try {
        await setDoc(gameRef, newGame);
    } catch (e) {
        console.error('Error starting game:', e);
    }
}

async function forfeitGame() {
    const ok = confirm('Are you sure you want to forfeit this game?');
    if (!ok) return;

    try {
        await deleteDoc(gameRef);
    } catch (e) {
        console.error('Error forfeiting game:', e);
    }
}

window.makeMove = async (index) => {
    try {
        await runTransaction(db, async (transaction) => {
            const gameDoc = await transaction.get(gameRef);
            if (!gameDoc.exists()) throw "Game not found!";
            
            const game = gameDoc.data();
            const { board, turn, playerXId, playerOId } = game;
            
            // Validation
            if (checkWinner(board)) throw "Game is already over!";
            if (board[index] !== null) throw "Cell is already taken!";
            if (turn === 'X' && currentUser.uid !== playerXId) throw "It's not X's turn!";
            if (turn === 'O' && currentUser.uid !== playerOId) throw "It's not O's turn!";
            if (!playerOId && activeChatType === 'user' && currentUser.uid !== playerXId) throw "You must be one of the players to make a move!";
            if (!playerOId && activeChatType === 'room' && currentUser.uid !== playerXId) {
                // Forfeit game if not player X and no player O
                transaction.delete(gameRef);
                throw "No opponent. Game forfeited.";
            }

            // Make the move
            board[index] = turn;
            
            // Check for winner/draw
            const winner = checkWinner(board);
            let nextTurn = turn === 'X' ? 'O' : 'X';
            
            // Update the game state
            transaction.update(gameRef, { 
                board: board, 
                turn: winner ? null : nextTurn, // Stop turn if winner found
                status: winner ? 'finished' : 'active',
                playerOId: playerOId || (turn === 'O' ? currentUser.uid : playerOId), // Set Player O if it was first move in a room chat
                playerOName: game.playerOName || (turn === 'O' ? currentUser.displayName : game.playerOName)
            });
        });
    } catch (e) {
        console.warn("Move failed: " + e);
    }
};

/* ========================== PROFILE PANEL TOGGLE + LOGOUT ========================== */
$('#navAvatar').onclick = () => {
  const panel = document.getElementById('profileAdminPanel');
  if(panel.style.display === 'none' || panel.style.display === ''){
    panel.style.display = 'block';
  } else {
    panel.style.display = 'none';
  }
};

$('#logoutBtn').onclick = async () => {
  const ok = confirm('Sign out?');
  if(ok) await signOut(auth);
};
const darkModeToggle = document.getElementById('darkModeToggle');

function updateToggleButtonText() {
  darkModeToggle.textContent = document.body.classList.contains('theme-dim') ? 'Light Mode' : 'Dark Mode';
}

darkModeToggle.onclick = () => {
  document.body.classList.toggle('theme-dim');
  if (document.body.classList.contains('theme-dim')) {
    localStorage.setItem('darkMode', 'enabled');
  } else {
    localStorage.removeItem('darkMode');
  }
  updateToggleButtonText();
};

if (localStorage.getItem('darkMode') === 'enabled') {
  document.body.classList.add('theme-dim');
}

updateToggleButtonText();
const msgInput = document.getElementById('msgInput');
const typingIndicator = document.getElementById('typingIndicator');

msgInput.addEventListener('input', () => {
  typingIndicator.style.display = 'block';
  clearTimeout(msgInput._typingTimeout);
  msgInput._typingTimeout = setTimeout(() => {
    typingIndicator.style.display = 'none';
    clearTimeout(msgInput._typingTimeout);
  }, 3000);
});

// A proper implementation would also update a 'typing' status in Firestore
// for the current chat, and listen for it in the other user's view.
// Since that is a complex addition, the current client-side-only indicator is left as a placeholder.
</script>

</body>
</html>
